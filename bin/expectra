#!/usr/bin/env python
import os
import shutil
import subprocess
import sys
import tempfile

import ase.io
import ase.lattice
from ase.calculators.neighborlist import NeighborList
import mpi4py.MPI
import numpy

COMM_WORLD = mpi4py.MPI.COMM_WORLD

BOHR = 0.529177249
RYD = 13.605698

def main():
    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument('--first-shell', action='store_true', default=True)
    parser.add_argument('--neighbor-cutoff', type=float, metavar='DISTANCE',
            help='1st neighbor cutoff distance', default=3.4)

    parser.add_argument('--multiple-scattering', action='store_true')
    parser.add_argument('--rmax', type=float, metavar='DISTANCE', 
            default=6.0, help='maximum scattering half-path length')

    parser.add_argument('--S02', type=float, metavar='FACTOR', 
            default=1.0, help='amplitude reduction factor')
    parser.add_argument('--energy-shift', type=float, metavar='ENERGY', 
            default=0.0, help='energy shift to apply in eV')
    parser.add_argument('--absorber', type=str, metavar='ELEMENT', 
            help='atomic symbol of the xray absorber')
    parser.add_argument('--ignore-elements', type=str, metavar='ELEMENTS',
            help='comma delimited list of elements to ignore in the ' + \
            'scattering calculation')
    parser.add_argument('--edge', type=str, help='one of K, L1, L2, L3',
                        default='K')

    subparsers = parser.add_subparsers(help='sub-command help')
    parser_snapshots = subparsers.add_parser('snapshots',
            help='average EXAFS signal from snapshots of a trajectory')
    parser_snapshots.add_argument('--skip', type=int, default=0,
            help='number of frames to skip at the beginning')
    parser_snapshots.add_argument('--every', type=int, default=1,
            help='number of frames to between each step')
    parser_snapshots.add_argument('trajectories', metavar='TRAJ', nargs='+',
            help='trajectory file (POSCAR, con, xyz)')
    parser_snapshots.set_defaults(func=snapshots_command)

    parser_modes = subparsers.add_parser('modes',
            help='average EXAFS signal from harmonic approximation using ' + \
            'normal modes')
    parser_modes.add_argument('--samples', type=int, default=100,
            help='number of samples to average together')
    parser_modes.add_argument('--temperature', type=float, default=298.0)
    parser_modes.add_argument('POSITIONS', help='structure file (POSCAR, con, xyz)')
    parser_modes.add_argument('EIGENVECTORS')
    parser_modes.add_argument('EIGENVALUES')
    parser_modes.set_defaults(func=modes_command)

    args = parser.parse_args()

    if args.ignore_elements:
        args.ignore_elements = args.ignore_elements.split(',')

    if args.multiple_scattering == True:
        args.first_shell = False

    args.func(args)


def getxk(e):
    return numpy.sign(e)*numpy.sqrt(numpy.abs(e))

def xk2xkp(xk, vrcorr):
    xk0 = xk*BOHR
    vr = vrcorr / RYD
    xksign = numpy.sign(xk0)
    e = xksign*xk0**2 + vr
    
    return getxk(e) / BOHR

def xkp2xk(xk, vrcorr):
    xk0 = xk*BOHR
    vr = vrcorr / RYD
    xksign = numpy.sign(xk0)
    e = xksign*xk0**2 - vr
    
    return getxk(e) / BOHR

def chi_path(path, r, sig2, energy_shift, s02, N):
    #this gives errors at small k (<0.1), but it doesn't matter
    #as the k-window should always be zero in this region
    #also uses real momentum for dw factor
    delta_k = 0.05
    vrcorr = energy_shift

    xkpmin = xk2xkp(path['xk'][0], vrcorr)
    n = int(xkpmin / delta_k)
    if xkpmin > 0.0: n += 1
    xkmin = n*delta_k

    npts = len(path['xk'])

    xkout = numpy.arange(xkmin, 20.0+delta_k, delta_k)
    xk0 = xkp2xk(xkout, vrcorr)

    f0      =  numpy.interp(xk0, path['xk'], path['afeff'])
    lambda0 =  numpy.interp(xk0, path['xk'], path['xlam'])
    delta0  =  numpy.interp(xk0, path['xk'], path['cdelta'] + path['phfeff'])
    redfac0 =  numpy.interp(xk0, path['xk'], path['redfac'])
    rep0    =  numpy.interp(xk0, path['xk'], path['rep'])
    p0      =  rep0 + 1j/lambda0
    dr = r - path['reff']

    chi = numpy.zeros(len(xk0), dtype=complex)
    
    chi[1:]  = redfac0[1:]*s02*N*f0[1:]/(xk0[1:]*(path['reff']+dr)**2.0)
    chi[1:] *= numpy.exp(-2*path['reff']/lambda0[1:])
    chi[1:] *= numpy.exp(-2*(p0[1:]**2.0)*sig2)
    chi[1:] *= numpy.exp(1j*(2*p0[1:]*dr - 4*p0[1:]*sig2/path['reff']))
    chi[1:] *= numpy.exp(1j*(2*xk0[1:]*path['reff'] + delta0[1:]))

    return xkout, numpy.imag(chi)

def read_xdatcar(filename):
    f = open(filename, 'r')
    lines = f.readlines()
    f.close()
    lattice_constant = float(lines[1].strip())
    cell = numpy.array([[float(x) * lattice_constant for x in lines[2].split()], 
                        [float(x) * lattice_constant for x in lines[3].split()], 
                        [float(x) * lattice_constant for x in lines[4].split()]])
    elements = lines[5].split()
    natoms = [int(x) for x in lines[6].split()]
    nframes = (len(lines)-7)/(sum(natoms) + 1)
    trajectory = []
    for i in range(nframes):
        a = ase.Atoms('H'*sum(natoms))
        a.masses = [1.0] * len(a)
        a.set_chemical_symbols(''.join([n*e for (n, e) in zip(natoms, elements)]))
        a.cell = cell.copy()
        j = 0
        for N, e in zip(natoms, elements):
            for k in range(N):
                split = lines[8 + i * (sum(natoms) + 1) + j].split()
                a[j].position = [float(l) for l in split[0:3]]
                j += 1
        a.positions = numpy.dot(a.positions, cell)
        trajectory.append(a)
    return trajectory

def feff_edge_number(edge):
    edge_map = {}
    edge_map['k'] = 1
    edge_map['l1'] = edge_map['li'] = 1
    edge_map['l2'] = edge_map['lii'] = 3
    edge_map['l3'] = edge_map['liii'] = 4
    return edge_map[edge.lower()]
        

def load_chi_dat(filename):
    f = open(filename)
    chi_section = False
    k = []
    chi = []
    for line in f:
        line = line.strip()
        if len(line) == 0:
            continue

        fields = line.split()
        if fields[0] == "k" and fields[1] == "chi" and fields[2] == "mag":
            chi_section = True
            continue

        if chi_section:
            k.append(float(fields[0]))
            chi.append(float(fields[1]))
    return numpy.array(k), numpy.array(chi)

def load_feff_dat(filename):
    xk = []
    cdelta = []
    afeff = []
    phfeff = []
    redfac = []
    xlam = []
    rep = []

    atoms = ase.Atoms()
    atoms.set_pbc((False,False,False))

    path_section = False
    atoms_section = False
    data_section = False
    f = open(filename)
    for line in f:
        line = line.strip()
        fields = line.split()
        if "genfmt" in line:
            path_section = True
            continue
        if fields[0] == "x" and fields[1] == "y" and fields[2] == "z":
            atoms_section = True
            path_section = False
            continue
        if fields[0] == "k" and fields[1] == "real[2*phc]":
            data_section = True
            atoms_section = False
            continue

        if path_section:
            if "---------------" in line:
                continue
            reff = float(fields[2])
            path_section = False

        if atoms_section:
            x = float(fields[0])
            y = float(fields[1])
            z = float(fields[2])
            pot = int(fields[3])
            atomic_number = int(fields[4])
            atoms.append(ase.Atom(symbol=atomic_number, position=(x,y,z),
                         tag=pot))

        if data_section:
            fields = [ float(f) for f in fields ]
            xk.append(fields[0])
            cdelta.append(fields[1])
            afeff.append(fields[2])
            phfeff.append(fields[3])
            redfac.append(fields[4])
            xlam.append(fields[5])
            rep.append(fields[6])

    xk = numpy.array(xk)
    cdelta = numpy.array(cdelta)
    afeff = numpy.array(afeff)
    phfeff = numpy.array(phfeff)
    redfac = numpy.array(redfac)
    xlam = numpy.array(xlam)
    rep = numpy.array(rep)

    return { 
             "atoms":atoms,
             "reff":reff,
             "xk":xk,
             "cdelta":cdelta,
             "afeff":afeff,
             "phfeff":phfeff,
             "redfac":redfac,
             "xlam":xlam,
             "rep":rep,
           }

def write_feff(filename, atoms, absorber, feff_options={}):
    f = open(filename, "w")
    f.write("TITLE %s\n" % str(atoms))
    for key, value in feff_options.iteritems():
        f.write("%s %s\n" % (key, value))
    f.write("\nPOTENTIALS\n")
    absorber_z = atoms[absorber].number
    f.write("%i %i\n" % (0, absorber_z))

    unique_z = list(set(atoms.get_atomic_numbers()))
    pot_map = {}
    i = 1
    for z in unique_z:
        nz = len( [ a for a in atoms if a.number == z ] )
        if z == absorber_z and nz-1==0:
            continue
        f.write("%i %i\n" % (i, z))
        pot_map[z] = i
        i+=1

    f.write("\nATOMS\n")
    for i,atom in enumerate(atoms):
        if i == absorber:
            pot = 0
        else:
            pot = pot_map[atom.number]
        f.write("%f %f %f %i\n" % (atom.x, atom.y, atom.z, pot))

def run_feff(atoms, absorber, feff_options={}, tmp_dir=None, get_path=False):
    tmp_dir_path = tempfile.mkdtemp(prefix="tmp_feff_", dir=tmp_dir)
    write_feff(os.path.join(tmp_dir_path, "feff.inp"), atoms, absorber, feff_options)
    p = subprocess.Popen(["feff"], cwd=tmp_dir_path, stdout=open('/dev/null','w'),
                         stderr=subprocess.PIPE)
    retval = p.wait()
    if retval != 0:
        print "Problem with feff calculation in %s" % tmp_dir_path
        return
    stdout, stderr = p.communicate()
    stderr = stderr.strip()
    if stderr == "hash error":
        atoms[absorber].set_position(atoms[absorber].get_position()+0.001)
        sys.stderr.write("%s\n"%stderr)
        return run_feff(atoms, absorber, feff_options, tmp_dir)
    k, chi = load_chi_dat(os.path.join(tmp_dir_path, "chi.dat"))
    if get_path:
        path = load_feff_dat(os.path.join(tmp_dir_path, "feff0001.dat"))
    shutil.rmtree(tmp_dir_path)

    if get_path:
        return k, chi, path
    else:
        return k, chi


def harmonic_sampler(atoms, ews, evs, temperature, iters):
    atoms = atoms.copy()
    r0 = atoms.get_positions()

    for iter in xrange(iters):
        r = r0.copy()
        for j in xrange(len(ews)):
            stddev = numpy.sqrt( (ase.units.kB*temperature)/ews[j])
            #mass = 196.96655
            #min_stddev = numpy.sqrt(0.0646562/(2.0*numpy.sqrt(ews[j]*mass)))
            min_stddev = 0.0
            stddev = max(min_stddev, stddev)
            g = numpy.random.normal(loc=0, scale=stddev)
            v = g*evs[:,j]
            r += v.reshape(len(atoms), 3)
        atoms.set_positions(r)
        yield atoms.copy()

def get_default_absorber(atoms, args):
    symbols = set(atoms.get_chemical_symbols())
    if args.ignore_elements:
        symbols -= set(args.ignore_elements)
    if len(symbols) == 1:
        return list(symbols)[0]
    else:
        print 'must specify --absorber if more than one chemical specie'
        sys.exit(2)

def save_result(k, chi):
    if COMM_WORLD.rank != 0: return
    print 'saving result to chi.dat'
    f = open('chi.dat', 'w')
    for i in xrange(len(k)):
        f.write("%6.3f %16.8e\n" % (k[i], chi[i]))
    f.close()

def modes_command(args):
    atoms = ase.io.read(args.POSITIONS)
    args.absorber = get_default_absorber(atoms, args)
    ews = numpy.loadtxt(args.EIGENVALUES, dtype=float)[6:]
    evs = numpy.loadtxt(args.EIGENVECTORS, dtype=float)[:,6:]

    ensemble = harmonic_sampler(atoms, ews, evs, args.temperature, 
            args.samples)

    trajectory = []
    for snapshot in ensemble:
        trajectory.append(snapshot)

    k, chi = exafs_trajectory(args, trajectory)
    save_result(k, chi)

def snapshots_command(args):
    trajectory = []
    for filename in args.trajectories:
        trajectory += read_xdatcar(filename)[:args.skip:args.every]
    args.absorber = get_default_absorber(trajectory[0], args)

    k, chi = exafs_trajectory(args, trajectory)
    save_result(k, chi)

def exafs_trajectory(args, trajectory):
    if args.multiple_scattering:
        k, chi = exafs_multiple_scattering(args.S02, args.energy_shift, 
                args.absorber, args.ignore_elements, args.edge, args.rmax, 
                trajectory)
    elif args.first_shell:
        k, chi = exafs_first_shell(args.S02, args.energy_shift, 
                args.absorber, args.ignore_elements, args.edge, 
                args.neighbor_cutoff, trajectory)

    return k, chi
    
def get_bond_pairs(atoms, cutoff=3.3):
    bonds = []                                                                  
    for i in range(len(atoms)):
        for j in range(i+1, len(atoms)):
            if atoms.get_distance(i,j,True) < cutoff:
                bonds.append( (i,j) )
    return bonds

def exafs_first_shell(S02, energy_shift, absorber, 
        ignore_elements, edge, neighbor_cutoff, trajectory):
        feff_options = {
                'RMAX':str(neighbor_cutoff),
                'HOLE':'%i %.4f' % (feff_edge_number(edge), S02),
                'CORRECTIONS':'%.4f %.4f' % (energy_shift, 0.0),
                'NLEG':'4'
        }

        #generate the bulk reference state 
        atoms = ase.lattice.bulk(absorber, orthorhombic=True, cubic=True)
        atoms = atoms.repeat((4,4,4))
        center = numpy.argmin(numpy.sum((atoms.get_scaled_positions() -
            numpy.array( (.5,.5,.5) ))**2.0, axis=1))
        #do the bulk reference scattering calculation and get the path
        #data from feff
        path = run_feff(atoms, center, feff_options, get_path=True)[2]

        k = None
        chi_total = None

        counter = 0
        nl = None
        for step, atoms in enumerate(trajectory):
            if COMM_WORLD.rank == 0:
                print 'step %i/%i' % (step+1, len(trajectory))
            atoms = atoms.copy()
            if ignore_elements:
                ignore_indicies = [atom.index for atom in atoms 
                                   if atom.symbol in ignore_elements]
                del atoms[ignore_indicies]
            if nl == None:
                nl = NeighborList(len(atoms)*[neighbor_cutoff], skin=0.3, 
                        self_interaction=False)
            nl.update(atoms)

            for i in xrange(len(atoms)):
                if atoms[i].symbol != absorber:
                    continue
                indicies, offsets = nl.get_neighbors(i)
                for j, offset in zip(indicies, offsets):

                    if counter % COMM_WORLD.size != COMM_WORLD.rank: 
                        counter += 1
                        continue
                    else:
                        counter += 1

                    r = atoms.get_distance(i,j,True)
                    k, chi = chi_path(path, r, 0.0, energy_shift, S02, 1)

                    if chi_total != None:
                        chi_total += chi
                    else:
                        chi_total = chi

        return k, chi_total

def exafs_multiple_scattering(S02, energy_shift, absorber, 
        ignore_elements, edge, rmax, trajectory):
        feff_options = {
                'RMAX':str(rmax),
                'HOLE':'%i %.4f' % (feff_edge_number(edge), S02),
                'CORRECTIONS':'%.4f %.4f' % (energy_shift, 0.0),
                'NLEG':'4'
        }

        k = None
        chi_total = None
        for atoms in trajectory:
            atoms = atoms.copy()
            if ignore_elements:
                ignore_indicies = [atom.index for atom in atoms 
                                   if atom.symbol in ignore_elements]
                del atoms[ignore_indicies]

            for i in xrange(len(atoms)):
                if atoms[i].symbol != absorber:
                    continue

                k, chi = run_feff(atoms, i, feff_options)
                if chi_total != None:
                    chi_total += chi
                else:
                    chi_total = chi

        return k, chi_total


if __name__ == '__main__':
    main()
