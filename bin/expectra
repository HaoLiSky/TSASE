#!/usr/bin/env python

import sys
from optparse import OptionParser
import math
import resource
import time

from mpi4py import MPI
def mpiexcepthook(type, value, traceback):
    sys.__excepthook__(type, value, traceback)
    sys.stderr.write("exception occured on rank %i\n", MPI.COMM_WORLD.rank);
    MPI.COMM_WORLD.Abort()
sys.excepthook = mpiexcepthook

class ASE_MPI4PY:
    def __init__(self):
        from mpi4py import MPI
        self.comm = MPI.COMM_WORLD
        self.rank = self.comm.rank
        self.size = self.comm.size

    def sum(self, a):
        return self.comm.allreduce(a)

    def barrier(self):
        self.comm.barrier()

    def broadcast(self, a, rank):
        a[:] = self.comm.bcast(a, rank)

import ase
ase.parallel.world = ASE_MPI4PY()
ase.parallel.rank = ase.parallel.world.rank
ase.parallel.size = ase.parallel.world.size
ase.parallel.barrier = ase.parallel.world.barrier
from ase.parallel import parprint, paropen
from ase.utils import devnull
from ase.md.langevin import Langevin
from ase.md.velocitydistribution import MaxwellBoltzmannDistribution
from ase.md import MDLogger
from ase import units
from ase.io.trajectory import PickleTrajectory
import tsase
import numpy
from qsc import QSC
from ase.optimize.optimize import Dynamics
from ase.units import kB
from ase.io.trajectory import PickleTrajectory

world = MPI.COMM_WORLD
rank = world.rank
size = world.size



class MetropolisMonteCarlo(Dynamics):
    def __init__(self, atoms,
                 temperature=100 * kB,
                 dr=0.001,
                 logfile='-', 
                 trajectory='monte_carlo.traj',
                 adjust_cm=True):
        Dynamics.__init__(self, atoms, logfile, trajectory)
        self.kT = temperature
        self.dr = dr
        self.accepts = 0
        self.total_steps = 0
        if adjust_cm:
            self.cm = atoms.get_center_of_mass()
        else:
            self.cm = None
        self.initialize()

    def initialize(self):
        self.positions = 0.0 * self.atoms.get_positions()
        self.positions = self.atoms.get_positions()
        self.call_observers()
        self.log(-1, self.atoms.get_potential_energy())
                
    def step(self):
        while True:
            yield self.run(1)
                
    def run(self, steps):
        E_current = self.atoms.get_potential_energy()
        for step in range(steps):
            ro = self.atoms.get_positions()
            self.move()
            E_trial = self.atoms.get_potential_energy()

            accept = numpy.exp((E_current - E_trial) / self.kT) > numpy.random.uniform()
            if accept:
                E_current = E_trial
                self.accepts += 1
            else:
                self.atoms.set_positions(ro)
            self.total_steps += 1
            self.log(self.total_steps, E_current)
            self.call_observers()

    def get_acceptance_ratio(self):
        return float(self.accepts)/float(self.total_steps)


    def log(self, step, E_current):
        if self.logfile is None:
            return
        name = self.__class__.__name__
        self.logfile.write('%s: step %2d, energy %15.6f\n'
                           % (name, step, E_current))
        self.logfile.flush()

    def move(self):
        atoms = self.atoms
        # displace coordinates
        disp = numpy.random.uniform(-1., 1., (len(atoms), 3))
        rn = atoms.get_positions() + self.dr * disp
        atoms.set_positions(rn)
        if self.cm is not None:
            cm = atoms.get_center_of_mass()
            atoms.translate(self.cm - cm)
        rn = atoms.get_positions()
        ase.parallel.world.broadcast(rn, 0)
        atoms.set_positions(rn)
        return atoms.get_positions()


class MDSnapshots:
    def __init__(self, atoms, options):
        self.atoms = atoms
        self.options = options
        self.max_snapshot_steps = 1000
        self.nsnapshots = 0

        calc = QSC()
        self.atoms.set_calculator(calc)
        MaxwellBoltzmannDistribution(atoms, options.temperature*units.kB)
        self.dyn = Langevin(self.atoms, options.time_step*units.fs, 
                             options.temperature*units.kB, 0.02)
        traj = PickleTrajectory("exafs_md.traj", 'w', self.atoms,
                                backup=False)
        self.dyn.attach(traj, interval=options.snapshot_steps)

        mdlog = MDLogger(self.dyn, self.atoms, "exafs_md.log", stress=False,
                         peratom=True, header=True)
        self.dyn.attach(mdlog, interval=options.snapshot_steps)

        self.simulation_time = options.equillibration_steps*options.time_step
        parprint("equillibrating for %.2e s" % (1e-15*self.simulation_time))
        self.dyn.run(options.equillibration_steps)
        self.first_time = True

    def __iter__(self):
        return self

    def next(self):
        if self.nsnapshots == self.max_snapshot_steps:
            raise StopIteration

        if self.first_time:
            self.first_time = False
            return self.atoms.copy()
        self.nsnapshots += 1

        self.dyn.run(self.options.snapshot_steps)
        self.simulation_time += self.options.snapshot_steps * \
                                self.options.time_step
        return self.atoms.copy()

class TrajectorySnapshots:
    def __init__(self, traj, options):
        self.traj = traj
        self.options = options
        self.frame = self.options.equillibration_steps

    def __iter__(self):
        return self

    def next(self):
        if self.frame >= len(self.traj):
            raise StopIteration
        rframe = self.traj[self.frame]
        self.frame += options.snapshot_steps
        return rframe

class AverageChi:
    def __init__(self):
        self.chis = {}
        self.residual = None

    def append(self, chi):
        old_average = self.get_average()
        for symbol in chi:
            if symbol not in self.chis:
                self.chis[symbol] = []
            self.chis[symbol].append(chi[symbol])
        new_average = self.get_average()

        if old_average == None:
            return
        residuals = []
        for symbol in self.chis:
            residual = numpy.linalg.norm(new_average[symbol] - 
                                         old_average[symbol])
            residuals.append(residual)
        self.residual = max(residuals)

    def get_average(self):
        if len(self.chis) == 0:
            return None
        result = {}
        for symbol in self.chis:
            result[symbol] = numpy.average(self.chis[symbol], axis=0)
        return result

def write_chi(k, average_chi, number=None):
    chi = average_chi.get_average()
    for symbol in chi:
        if number:
            fn_chi = "chi_%s_%i.dat" % (symbol, number)
            fn_kchi = "kchi_%s_%i.dat" % (symbol, number)
        else:
            fn_chi = "chi_%s.dat" % symbol
            fn_kchi = "kchi_%s.dat" % symbol
        f_chi = paropen(fn_chi, "w")
        f_kchi = paropen(fn_kchi, "w")
        for j in range(len(k)):
            f_chi.write("%f %f\n"%(k[j],chi[symbol][j]))
            f_kchi.write("%f %f\n"%(k[j],k[j]*chi[symbol][j]))
        f_chi.close()
        f_kchi.close()


def main(options, filename):
    start_time = time.time()
    if options.read_trajectory:
        traj = PickleTrajectory(filename)
        snapshots = TrajectorySnapshots(traj, options)
    else:
        if filename[-3:] == "con" and '.' in filename:
            atoms = tsase.io.read_con(filename)
        else:
            atoms = ase.io.read(filename)
        snapshots = MDSnapshots(atoms, options)


    chi_md = []
    iter_below_tol = 0

    average_chi = AverageChi()

    f_converge = open("convergance.dat", "w")
    for i, atoms in enumerate(snapshots):
        k, chi = tsase.exafs.exafs(atoms, txt=None)
        average_chi.append(chi)

        res = average_chi.residual
        if res:
            if res < options.residual:
                iter_below_tol += 1
            else:
                iter_below_tol = 0
            s = "iter: %3i log10(residual): %.1f %2i" % (i, math.log10(res), 
                                                         iter_below_tol)
            parprint(s)
            f_converge.write("%i %f\n" % (i, math.log10(res)))
            f_converge.flush()
        if options.write_every_step:
            write_chi(k, average_chi, i)
        #convergence check
        if iter_below_tol == options.residual_steps:
            break
    f_converge.close()
    end_time = time.time()
    parprint("spectra calculation complete")
    parprint("averaged over %i MD configurations" % i)

    write_chi(k, average_chi)

    rusage = resource.getrusage(resource.RUSAGE_SELF)
    utime = world.reduce(rusage.ru_utime)
    stime = world.reduce(rusage.ru_stime)

    if rank == 0:
        parprint("real:   %.2f" % (end_time-start_time))
        parprint("user:   %.2f" % (utime/float(world.size)))
        parprint("system: %.2f" % (stime/float(world.size)))


if __name__ == "__main__":
    parser = OptionParser(usage="%prog [options] FILE")
    parser.add_option("-r", "--read-trajectory",
                      action="store_true", default=False,
                      help="instead of running an md simulation read " \
                           "in a ASE trajectory file [default: %default]")
    parser.add_option("--write-every-step", default=False,
                      action="store_true",
                      help="write out chi and kchi at every step intead " \
                           "of just at the end [default: %default]")
    parser.add_option("--residual", default=1e-4, type="float",
                      help="residual convergence critera [default: %default]")
    parser.add_option("--residual-steps", default=10, type="int",
                      help="number of consecutive steps that the residual "\
                           "critera must be satisfied for [default: %default]")
    parser.add_option("-e", "--equillibration-steps",
                      type="int", action="store", default=5000,
                      help="number of time steps/traj frames skipped " \
                           "before the exafs averaging begins [default: %default]")
    parser.add_option("-s", "--snapshot-steps",
                      type="int", default=10,
                      help="the number of steps/frames between each exafs " \
                           "calculation [default: %default]")
    parser.add_option("-t", "--temperature",
                      type="float", action="store", default=300.0,
                      help="temperature for md simulation in Kelvin [default: %default]")
    parser.add_option("--time-step", dest="time_step",
                      type="float", action="store", default=1.0,
                      help="time step for md simulation in fs [default: %default]")

    options, args = parser.parse_args()

    if len(args) != 1:
        parser.print_help(sys.stderr)
        if options.read_trajectory:
            if rank == 0:
                sys.stderr.write("Error: must specify an ASE traj file\n")
        else:
            if rank == 0:
                sys.stderr.write("Error: must specify a con file\n")
        sys.exit(1)

    if options.read_trajectory:
        options.equillibration_steps = 0

    main(options, args[0])
